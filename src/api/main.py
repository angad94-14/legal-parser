"""
Main FastAPI application.

Design Rationale:
- Modular architecture (separate routers for extraction vs RAG)
- Proper error handling
- CORS enabled for web frontend
- Health check endpoint
- API documentation (auto-generated by FastAPI)

Interview Note: This shows production-ready API design.
"""

from fastapi import FastAPI, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from datetime import datetime
import logging

from src.api.models import HealthResponse, ErrorResponse

# Load .env into environment variables
from dotenv import load_dotenv
load_dotenv()

# Initialize logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Create FastAPI app
app = FastAPI(
    title="Legal Contract Parser API",
    description="""
    AI-powered legal contract analysis API.

    Features:
    - **Extraction**: Extract structured data from contracts (parties, terms, clauses)
    - **RAG**: Semantic search and question-answering across contracts

    Built with: FastAPI, OpenAI, LangChain, ChromaDB
    """,
    version="0.1.0",
    docs_url="/docs",  # Swagger UI
    redoc_url="/redoc",  # ReDoc UI
)

# ============================================================================
# MIDDLEWARE
# ============================================================================

# CORS middleware
# Rationale: Allow frontend (React, Vue, etc.) to call API
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production: specify allowed origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# ============================================================================
# EXCEPTION HANDLERS
# ============================================================================

@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc):
    """
    Global HTTP exception handler.

    Rationale: Consistent error response format.
    """
    return JSONResponse(
        status_code=exc.status_code,
        content=ErrorResponse(
            error=f"HTTP_{exc.status_code}",
            message=exc.detail,
            timestamp=datetime.utcnow()
        ).model_dump(mode='json')
    )


@app.exception_handler(Exception)
async def general_exception_handler(request, exc):
    """
    Global exception handler for unhandled errors.

    Rationale: Catch-all for unexpected errors.
    - Prevents server from crashing
    - Logs error for debugging
    - Returns user-friendly message
    """
    logger.error(f"Unhandled exception: {str(exc)}", exc_info=True)

    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content=ErrorResponse(
            error="INTERNAL_SERVER_ERROR",
            message="An unexpected error occurred. Please try again later.",
            timestamp=datetime.utcnow()
        ).model_dump(mode='json')
    )


# ============================================================================
# CORE ENDPOINTS
# ============================================================================

@app.get("/", tags=["General"])
async def root():
    """
    Root endpoint - API information.

    Rationale: Welcoming landing page for API.
    """
    return {
        "message": "Legal Contract Parser API",
        "version": "0.1.0",
        "docs": "/docs",
        "health": "/health"
    }


@app.get("/health", response_model=HealthResponse, tags=["General"])
async def health_check():
    """
    Health check endpoint.

    Rationale: Standard endpoint for monitoring/load balancers.
    - Kubernetes liveness probe
    - Load balancer health check
    - Monitoring systems (Datadog, New Relic)

    Returns health status of:
    - API service itself
    - Vector database connection
    - LLM API availability
    """
    # Check dependencies
    dependencies = {}

    # Check vector store
    try:
        from src.rag.retriever import RAGRetriever
        retriever = RAGRetriever()
        # Try a simple operation
        retriever.vector_store._collection.count()
        dependencies["vector_store"] = "healthy"
    except Exception as e:
        logger.error(f"Vector store health check failed: {e}")
        dependencies["vector_store"] = "unhealthy"

    # Check OpenAI API
    try:
        from src.utils.config import settings
        from openai import OpenAI
        client = OpenAI(api_key=settings.openai_api_key)
        # Simple API call to verify connectivity
        # Note: This costs ~$0.00001
        client.models.list()
        dependencies["openai_api"] = "healthy"
    except Exception as e:
        logger.error(f"OpenAI API health check failed: {e}")
        dependencies["openai_api"] = "unhealthy"

    # Determine overall status
    if all(status == "healthy" for status in dependencies.values()):
        overall_status = "healthy"
    elif any(status == "unhealthy" for status in dependencies.values()):
        overall_status = "degraded"
    else:
        overall_status = "unhealthy"

    return HealthResponse(
        status=overall_status,
        version="0.1.0",
        timestamp=datetime.utcnow(),
        dependencies=dependencies
    )


# ============================================================================
# IMPORT ROUTERS
# ============================================================================

# Import routers (we'll create these next)
from src.api.routers import extraction, rag

# Include routers
app.include_router(
    extraction.router,
    prefix="/extract",
    tags=["Extraction"]
)

app.include_router(
    rag.router,
    prefix="/rag",
    tags=["RAG"]
)


# ============================================================================
# STARTUP/SHUTDOWN EVENTS
# ============================================================================

@app.on_event("startup")
async def startup_event():
    """
    Run on application startup.

    Rationale: Initialize resources, warm up models, etc.
    """
    logger.info("ðŸš€ Starting Legal Contract Parser API")
    logger.info("ðŸ“š API docs available at: http://localhost:8000/docs")


@app.on_event("shutdown")
async def shutdown_event():
    """
    Run on application shutdown.

    Rationale: Clean up resources, close connections, etc.
    """
    logger.info("ðŸ‘‹ Shutting down Legal Contract Parser API")